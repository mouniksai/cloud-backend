// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// 1. USERS & CITIZENS
model GovtRegistry {
  citizenId    String   @id @unique @map("citizen_id")
  fullName     String   @map("full_name")
  constituency String   @default("General")
  ward         String   @default("Ward A")
  dob          DateTime @db.Date
  gender       String?
  email        String   @unique
  mobile       String   @unique
  photoUrl     String?  @map("photo_url")
  isRegistered Boolean  @default(false) @map("is_registered")

  User User?
  @@map("govt_registry")
}

model User {
  userId       String   @id @default(uuid()) @map("user_id") @db.Uuid
  username     String   @unique
  passwordHash String   @map("password_hash")
  role         String   @default("voter")
  
  // OTP fields for 2FA
  otpCode      String?  @map("otp_code")
  otpExpiresAt DateTime? @map("otp_expires_at")
  
  citizenId    String       @unique @map("citizen_id")
  citizen      GovtRegistry @relation(fields: [citizenId], references: [citizenId])
  
  votes        Vote[]
  auditLogs    AuditLog[]

  @@map("users")
}

// 2. ELECTION MODULE
model Election {
  id            String      @id @default(uuid())
  title         String
  description   String
  constituency  String
  startTime     DateTime    @map("start_time")
  endTime       DateTime    @map("end_time")
  status        String      @default("UPCOMING") // UPCOMING, LIVE, ENDED
  
  candidates    Candidate[]
  votes         Vote[]
  
  @@map("elections")
}

model Candidate {
  id          String   @id @default(uuid())
  name        String
  party       String
  symbol      String   // E.g., "üå≥", "‚≠ê"
  
  // --- NEW FIELDS ADDED HERE ---
  age         Int
  education   String
  experience  String
  // -----------------------------

  keyPoints   String[] // Manifesto points
  voteCount   Int      @default(0) // Fast analytics counter

  electionId  String   @map("election_id")
  election    Election @relation(fields: [electionId], references: [id])
  
  votes       Vote[]

  @@map("candidates")
}

// 3. SECURE VOTE LEDGER
model Vote {
  id            String   @id @default(uuid())
  
  // Who voted?
  userId        String   @map("user_id") @db.Uuid
  user          User     @relation(fields: [userId], references: [userId])

  // Which election?
  electionId    String   @map("election_id")
  election      Election @relation(fields: [electionId], references: [id])

  // Who did they choose?
  candidateId   String   @map("candidate_id")
  candidate     Candidate @relation(fields: [candidateId], references: [id])

  // CYBER SECURITY COMPONENT: Receipt Hash
  // Instead of blockchain, we store a SHA-256 hash of the vote details.
  receiptHash   String   @unique @map("receipt_hash")
  
  // ENCRYPTION COMPONENT: For Lab Evaluation
  encryptedDetails String? @map("encrypted_details")
  
  timestamp     DateTime @default(now())

  // CRITICAL: Composite unique key prevents double voting at the Database Level
  @@unique([userId, electionId]) 
  @@map("votes")
}

// 4. AUDIT LOGS (Non-Repudiation)
model AuditLog {
  id        String   @id @default(uuid())
  userId    String   @map("user_id") @db.Uuid
  action    String   
  details   String?
  ipAddress String?  @map("ip_address")
  timestamp DateTime @default(now())

  user      User     @relation(fields: [userId], references: [userId])

  @@map("audit_logs")
}